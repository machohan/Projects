
<html>
<head>
<title>Implementing malloc</title>
</head>
<body>
<h1>
      Implementing <code>malloc</code>
    </h1>
	

<h2>Introduction</h2>

<p>The library functions and system calls that implement dynamic memory allocation operate on a contiguous region of memory called the heap.  Your task is to implement simple versions of <code>malloc</code> and <code>free</code> called <code>smalloc</code> and <code>sfree</code>.  These two functions will operate nearly the same way as <code>malloc</code> and <code>free</code>: <code>smalloc</code> makes memory available ("allocates memory") and <code>sfree</code> frees that memory.
One difference between <code>free</code> and your <code>sfree</code> is that <code>sfree</code> will return a -1 on error and a 0 on success.  (The library <code>free</code> call doesn't return any value.)</p>

<h2>Details</h2>

<p>You are given some starter code for this assignment.  It will compile, but will not operate correctly until you implement the following four functions:</p>

<ul>
    <li><code>mem_init()</code>: (5%) Initializes the data structures that manage the dynamic memory allocation. Part of this function is given to you. A large region of memory is reserved using <code>mmap</code>.  The comments above <code>mem_init</code> in the starter code explain how <code>mmap</code> is called.  Using <code>mmap</code> in this way means that you are free to use <code>malloc</code> as normal to create your linked lists. (This is the only place in the code where <code>mmap</code> is used.)
    </li>
    <li><code>void *smalloc(unsigned int nbytes)</code>: (30%) Reserves <code>nbytes</code> <b>bytes</b> of space from the memory region created by <code>mem_init</code>. If the memory is reserved (allocated) successfully,
    Returns a pointer to the reserved memory. If the memory cannot be reserved (i.e. there is no block that is large enough to hold <code>nbytes</code> bytes), returns <code>NULL</code>.</li>
    <li><code>int sfree(void *addr)</code>: (30%) Returns memory allocated by <code>smalloc</code> to the list of free blocks so that it might be reused later.</li>
    <li><code>mem_clean()</code>: (10%) Uses <code>free</code> (that's the C function <code>free</code>, not your <code>sfree</code>!) to free <b>all</b> the dynamically allocated memory (<code>allocated_list</code> and <code>freelist</code>) used by the program before exiting. (The <code>valgrind</code> program must show <code>all heap memory freed</code>, otherwise you have a memory leak. See below.)</li>
</ul>

<p>There are three global variables that define the data structures required:</p>
<ul>
    <li><code>mem</code> stores the starting address of the memory region that is reserved by <code>mem_init</code>.</li>
    <li><code>freelist</code>: A linked list of <code>struct block</code>s that identify the portions of the memory region that are free (not in use). Blocks in this list are stored in increasing address order.</li>
    <li><code>allocated_list</code>: A linked list of <code>struct block</code>s that identify portions of memory that have been reserved by calls to <code>smalloc</code>. When a block is allocated it is placed at the front of this list, so the list is unordered.</li>
</ul>
    
<p>You can think of the address returned by <code>mem_init</code> as the start of a large array of bytes, and it is your job to partition it up when <code>smalloc</code> is called. Your program will keep track of two linked lists of blocks (using <code>struct block</code>): a list of allocated blocks (<code>allocated_list</code>) and a list of freed blocks (<code>freelist</code>).  To complete <code>mem_init</code>, you need to create a block node with the starting address as given by <code>mmap</code>.  Therefore, after <code>mem_init</code> completes, the <code>allocated_list</code> will be empty (but initialized!), and <code>freelist</code> will have one block in it where the address contained in that block is the address returned by <code>mmap</code>.</p>

<p>The following diagram shows the state of memory after <code>mem_init</code> has been called.</p>

<img alt="The state of memory after mem_init has been called.  mem points to the starting address of the space reserved by mmap.  freelist points to a single node where the addr field holds the same value as mem, and the size field is the amount of memory reserved by mmap" src="http://s27.postimg.org/kok4qgynn/image.png">

<p>When <code>smalloc(nbytes)</code> is called, it searches the <code>freelist</code> for a block that is at least <code>nbytes</code> bytes in size. There are two possibilities for success: it might find a block of exactly the required size, or it might find a block that is larger than the required size.  If it finds a block that is larger than <code>nbytes</code> bytes, then it will split the block into two blocks.  The first block, containing the address and size of the allocated block, is placed at the beginning of the <code>allocated_list</code>, and the block containing the address and size of the remaining memory stays in the <code>freelist</code>.</p>

<h2>Example</h2>

<p>Suppose we have a test program that makes the following three calls to <code>smalloc</code>.  The state of the lists are shown in the diagram below:</p>
<pre>
    void *ptrs[3];
    ptrs[0] = smalloc(16);
    ptrs[1] = smalloc(24);
    ptrs[2] = smalloc(32);
</pre>

<img alt="The freelist has one node with addr = 0x7ffff7f8d048 and size = 262702.  The allocated_list has three nodes: [addr:0x7ffff7f8d000, size:16], [addr:0x7ffff7f8d010, size=24], [addr:0x7ffff7f8d028, size=32]" src="http://s15.postimg.org/kv9crgpaz/image.png">

<p>The next diagram shows the state of the two lists after the following call to <code>sfree</code>:</p>
<pre>
    sfree(ptrs[1]);
</pre>
<img alt="freelist = [addr:0x7ffff7f8d010, size=24],[addr: 0x7ffff7f8d048,size = 262702].  The allocated_list: [addr:0x7ffff7f8d000, size:16], [addr:0x7ffff7f8d028, size=32]" src="http://s4.postimg.org/kd4k79dkt/image.png">


<h2>Testing (15%)</h2>

<p>(10%) In addition to writing the four functions to implement the dynamic memory system, you will also write one test program in <tt>mytest.c</tt> that tests your functions.  You may use <code>simpletest.c</code> as a guide for how to write a test, but your program must test an interesting test case.  Determining what makes an interesting case is a decision you need to make, and part of what we are marking.  Your <tt>mytest.c</tt> program must include a comment at the top of the file explaining the case that is tested and why it is an interesting test case.</p>

<p>To make <code>simpletest</code> fully work, you will need to complete the <code>print_list</code> function.</p>

<p>(5%) Add a rule (or rules) to the <code>Makefile</code> to build an executable called <tt>mytest</tt>. </p>

<p>Add another rule to the <code>Makefile</code> with the target <code>tests</code> and the prerequisites <code>simpletest</code> and <code>mytest</code> that runs both test programs.</p>

<h2>Valgrind</h2>

<p><a href="http://valgrind.org"><code>valgrind</code></a> is a very useful tool for checking for memory errors. We will primarily use it to make sure that there are no memory leaks in our programs.  Run it as:</p>
<pre>
    valgrind simpletest
</pre>
<p>The output includes the output from simpletest.  The output from valgrind will be prefixed with something that looks like "<code>==10320== </code>"  (The number is the process id of the simpletest process and will change from run to run.)  The information from valgrind that is most useful is near the bottom:</p>
<pre>
    ==10320== 
    ==10320== HEAP SUMMARY:
    ==10320==     in use at exit: 0 bytes in 0 blocks
    ==10320==   total heap usage: 5 allocs, 5 frees, 120 bytes allocated
    ==10320== 
    ==10320== All heap blocks were freed -- no leaks are possible
    ==10320== 
    ==10320== For counts of detected and suppressed errors, rerun with: -v
    ==10320== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</pre>

<p>The message you want to see is "All heap blocks were freed -- no leaks are possible."  (The suppressed errors are not important.)</p>



<h2>Code Quality (10%)</h2>

<p>Code quality is always important. Use clear variable names, consistent formatting, informative comments, and good design. Compared to A1, there are more clear opportunities for modularization in your code for A2.</p>
    

<h2>What to submit</h2>

<p>You will commit to your repository in the <tt>a2</tt> directory <b>all</b> files required to build your program.  This includes the <code>Makefile</code>, all source code (<code>.c</code>) and header files (<code>.h</code>).</p>

<p>Make sure that you've done <tt>svn add</tt> on every file. Check MarkUs, or checkout your repository into a new directory, to verify that everything is there. There's nothing we can do if you forget to submit a file.</p>

<p>You should be able to run <code>valgrind simpletest</code> and see the message <em> All heap blocks were freed -- no leaks are possible</em>.</p>

<p><b>Submission checklist:</b></p>

<p>You can make your life a lot simpler by ensuring that your submission is complete. When you first sit down to do some work on this assignment, check out the repository. Notice which files are already in the repository.  Every time you create a new file, run <code>svn add</code> immediately to ensure that future commit operations will commit the new file as well.</p>

<p>Use version control as it was meant to be used.  Commit your work frequently -- at least once every 2-3 hours that you are working on the assignment.  This will prevent any last minute svn problems, and provide a record of your work.</p>

<p>Here is a list of things that you should do at least an hour before the assignment deadline:</p>
<ul>
    <li>Create a temporary directory in your account (not one that is a subdirectory of your working directory for your repository).</li>
    <li>Check out your repository into this empty directory to be sure that the correct files have been committed.</li>
    <li>Run <tt>make</tt> to be sure that at least the <code>simpletest</code> program compiles without warnings or error.</li>
    <li>Run <code>simpletest</code> and your own tests to be sure that everything works as expected.</li>
    <li>Run <tt>valgrind simpletest</tt> to make sure that no memory is left allocated in the heap.</li>
</ul>
</body>
</html>
